# Умные буферы автосипов

## Проблема

Раньше буфер применялся всегда, что приводило к нежелательным задержкам CIP даже когда в них не было необходимости.

## Решение

Буфер применяется **только при риске частых CIP**, когда после обычного CIP остается слишком мало места до следующего.

### Логика работы

```
1. Проверить обычный порог (volume_threshold)
2. Если порог превышен:
   - Рассчитать остаток после CIP: remainder = total - threshold
   - Если remainder < min_remainder:
     - Применить буфер: сдвинуть CIP вперед на (min_remainder - remainder)
   - Иначе: использовать обычный порог
```

### Примеры

#### Пример 1: Буфер НЕ применяется (остаток достаточный)
```
Порог: 50000
Буфер: 2000
Накоплено: 53000
Остаток после CIP: 3000 >= 2000
Результат: CIP вставляется на 50000
```

#### Пример 2: Буфер применяется (остаток малый)
```
Порог: 50000
Буфер: 2000
Накоплено: 50500
Остаток после CIP: 500 < 2000
Буфер нужен: 1500
Результат: CIP вставляется на 51500
```

### Интерфейс настройки

В окне "Настройки автоматических CIP" добавлено поле "Буфер":

```
Порог общего объема: [50000]    Порог по продукту: [30000]    Буфер: [2000]    Тип CIP: [CIP2 ▼]
```

### Преимущества

1. **Интеллектное применение** - буфер используется только когда нужно
2. **Избежание лишних задержек** - обычные случаи работают без буфера
3. **Гибкая настройка** - буфер можно настроить для каждой линии
4. **Предотвращение частых CIP** - система сама решает, когда нужен буфер

### Логирование

```
[АВТО-CIP] Общий объем достиг 50000 шт
[АВТО-CIP] Общий объем достиг 51500 шт (буфер 1500 для предотвращения частых CIP)
```

### Файлы изменений

- `schedule_tab.py` - обновлена логика буферов и интерфейс
- `cip_thresholds.json` - добавлено поле min_remainder
- `test_smart_buffer.py` - тесты умной логики буферов

### Совместимость

- Работает совместно с избежанием конфликтов CIP
- Буфер применяется перед поиском свободных слотов
- Полная обратная совместимость с существующими настройками
